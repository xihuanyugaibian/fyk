# 并发编程的挑战

## 上下文切换

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。  
所以任务从保存到再加载的过程就是一次上下文切换。

多线程不一定快，当并发执行累加操作不超过百万次时，速度会比串行执行累加操作更慢。因为线程有创建和上下文切换的开销。

减少上下文切换的方法有 无锁并发编程、CAS算法、使用最少线程和协程

* 无锁并发编程：多线程竞争锁时，会引起上下文切换，当多线程处理数据时，可以用一些方法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
* CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
* 使用最少线程：避免创建不需要的线程，如果任务少，没必要创建很多线程来处理。
* 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 死锁

死锁一旦发生，很难人为干预，在设计时，尽量避免。

1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用lock.tryLock(timeOut)来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现锁失败的情况。

## 资源限制的挑战

资源限制是指在并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。  
在并发编程中，讲代码执行速度加快的原则是将代码中串行执行的部分编程并发执行，但是如果将其某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这是程序的执行反而更慢，因为增加了上下文切换和资源调度的时间。

# Java并发机制的底层实现原理

## volatile的应用

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的可见性。可见性是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。  
如果volatile变量修饰符使用恰当的话，它比使用synchronized的使用和执行成本更低，因为它不会引起上下文切换和调度。

volatile修饰的共享变量进行下操作的时候会多出汇编代码 `lock addl $0x0,(%esp)`。  
lock前缀的指令在多核处理器下会引发两件事情

1. 将当前处理器缓存行的数据写回系统内存。
2. 这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。

## synchronized的实现原理与应用

monitorenter指令是在编译后插入同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证monitorecter必须有对应的monitorexit与之配对。  
**任何一个对象都有一个monitor与之关联，当且仅当一个monitor被持有后，它将处于锁定状态。** 线程执行到monitorehter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

### Java对象头

synchronized用的锁是存在Java的对象头里的。如果对象是数组，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2个字宽存储对象头。  
在32位虚拟机中，1字宽=4字节即32bit。64位虚拟机1字宽=64bit。
MarkWord：存储对象的hashCode或锁信息
ClassMetadataAddress：存储对象数据类型的指针
ArrayLength：数组的长度（数组对象才有）

### 锁的升级与对比

Java1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。此时锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。  
这几种状态会随着竞争情况逐渐升级。锁可以升级但不可以降级，目的是为了提高获得锁和释放锁的效率。

偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。


